wsl.exe --update
wsl --install
docker -v
docker pull [imgName]
docker pull [imgName]:[version]
docker run [imgName]
docker images
docker search [imgName]
docker ps/ docker container ls
docker ps -a
docker run --name abcContainer -d [imgName or imgId] -> in detach mode
docker run -it -d [imgName] -> interactive mode + detach mode
docker exec -it [containerId] [cmd which u want to exec eg python3/jshell/bash, u can see this in docker ps]
docker exec -i -t [containerId] sh
mysql -p -> for mysql terminal
/exit -> to exit from jshell
docker run --name [xyz] -e MYSQL_ROOT_PASSWORD=[password eg root] -d [imgName]
docker inspect [containerId/imgId] 
docker run --name [nginxServer] -d -p 8080:80 [imgName]
docker stop [containerName or Id]
docker start [containerName or Id]
docker restart [containerName or Id] -> when config changed for nginx or anything then we restart like this
docker kill [containerName or Id] -> force stop
docker rm [containerId] [another Id if to stop more containers]
docker rm -f [containerId]
docker rmi [imgName]

docker system prune -a -f -> will remove all cache so when creating img again will download everything again


[
 docker run -it ubuntu
 touch names.txt
 echo "message"
 docker start [containerId]
 docker exec -it [containerId] bash 
 docker commit -m "added txt file" [containerId] [imgName, custom name]
 docker stop [containerId]
 docker run -it [imgName, used ]
]

[
docker run -it ubuntu
apt-get update
apt-get install -y python3
]


docker login
docker commit
docker push
docker network
docker copy
docker logs [containerName]
docker volume
docker logout

docker build -t [tag img Name] . -> to build img in . curr folder

...................................

sudo su -> to get super user access
docker run -it -d --name [abcContainername] -p 80:80 [imgName] -> interactice, detach mode, name, port publish at 0.0.0.0:80->80 localhost0.0.0.0 80 is default of container
[
docker exec -it [containerName] bash
apt update
apt install nginx -y -> y puts yes if it askes for it
service nginx status -> status of nginx
service nginx start -> start nginx
exit
take ip address of VM & put in browser to run nginx
]

docker commit [containerId] [newImgName] -> when we want to save all configs which we did in container, we have to give it a new img name
docker tag [imgName] [username/newImgName] -> to give new name to an img, give username of docker hub & then /
docker login
docker push [username/newImgName:tagname] -> to push img with given tag version

Few Docker File Commands: FROM, WORKDIR, ADD, COPY, RUN, CMD, VOLUME, EXPOSE, ENTRYPOINT, LABEL
[
main.py
dockerfile
 [
  FROM ubuntu:latest
  WORKDIR /app -> creates a work dir (to run shell cmds in this dir during build time of img) /app if not present
  ADD . /app -> everything in my local curr dir goes to /app
  RUN apt update && apt install python -y                    -> \ &  | can also be used to merge into 1 layer
  CMD python /app/main.py
  CMD ["service", "nginx", "start"]
  LABEL maintainer="sagichani@pxc.com" 
 ]
docker build -t [custom-img-name] . -> build img & find docker file in . curr dir
]

............................................

Storage: Volumes, Bind Mount, Tmpfs mount

docker volume create [volName] -> create volume
docker volume ls
docker volume inspect [volName] -> more info of vol
docker volume rm [volName] -> remove vol
docker volume prune -> del all vol
docker run -it -d --name [containerName] --mount source=[volName],target=/apps [imgName] -> create src vol if not present, target is place where vol is mapped inside container, mount can be used for bind, tmpfs, and even vol 
docker run -it -d --name [containerName] --mount source=[volName],target=/apps,readonly [imgName] -> readonly vol
docker container inspect [containerName]
docker run -it -d --name [containerName] --volume [volName]:/apps [imgName] -> vol used for only vol

[
 docker run -it -d --name [containerName] --mount type=bind,source=$(pwd)/custom_dir,target=/apps [imgName] -> bind mount which docker doesn't manage
 docker run -it -d --name [containerName] --mount type=bind,source=$(pwd)/custom_dir,target=/apps,readonly [imgName] -> all info inside /custom_dir is readonly for container, but can add
 docker exec -it [containerName] bash
 ls -> /apps folder as workdir should be there
 cd apps/
 touch hello.txt
 exit
 -> now whatever we created in /apps in docker will be present in local or host system /custom_dir
 touch abc.txt -> inside local /custom_dir
 docker exec -it [containerName] bash
 ls
 cd apps/
 -> now whatever we created in local or host system /custom_dir will be present in /apps in docker
]

tmpfs -> store data on host or local sys (only on linux), but temp, gets del if container attached to it are stopped, thus gets mapped to only 1 container in their lifetime
[
 docker run -it -d --name [containerName] --mount type=tmpfs,target=/apps [imgName] -> src not req
 docker run -it -d --name [containerName] --tmpfs /apps [imgName] -> short cmd
]

....................................................

Network driver: Bridge(default), Host, Overlay, Macvlan, None

docker network create --driver [networkdrivertype] [networkName]
docker network ls
docker network inspect [networkId/networkName]

[
 docker exec -it [containerName] bash
 apt update && apt install iputils-ping -y
 docker network inspect [networkId/networkName] -> get container's ip u want to ping
 docker exec -it [containerName] bash -> in which u installed bash
 ping [ip]
]

docker run -it -d --network host --name [containerName] [imgName] -> container will not have any ip, it will share namespace/ip with host
curl localhost


docker swarm init -> create a ntwrk or swarm on this server & create it as manager node
docker network create --driver overlay [overlaynetworkName]

docker service create --name [serviceName] --network [networkName] --replicas 3 [imgName] -> creates 3 containers & put in 1 network
docker service ps [serviceName]
docker service ls 

docker run -it -d --name [containerName] --network none [imgName]

..............................................................

download docker compose seperately via cmd "curl -L "https://github.com/docker/compose..." -o /usr/local/bin/docker-compose"
chmod +x /usr/local/bin/docker-compose
docker-compose --version

docker-compose.yml file (2 spaces, have to define mysql root password, etc)
[
 version:'3'
 networks:
   [networkName]:
     driver: bridge/overlay/
 
 services:
   OS:
    image: "[imgName]"
    ports:
      - "80:80"
    networks:
      - [networkName]
   
   database:
     image: "mysql"
     networks:
       - [networkName]
     volume:
       - db_data:/var/lib/mysql
     restart: always
     environment:
       MYSQL_ROOT_PASSWORD: admin123
       MYSQL_DATABASE: [dbName]
       MYSQL_USER: [username]
       MYSQL_PASSWORD: [password]
     
   volumes:
     db_data: {} 
]

docker-compose up
docker-compose ps
docker-compose down
curl localhost:5000
docker-compose stop

docker-compose run db/wordpress env -> list of env var

docker stack deploy -c docker-compose.yml fun

.......................................................................

docker swarm init --advertise-addr [ip of manager node]
to add worker cmd is given
docker node ls
docker info
docker swarm leave -> if node wants to leave from the swarm
docker swarm join-token worker/manager -> to make node as worker or manager, if no manager than swarm gets killed
docker node rm [nodeId]



